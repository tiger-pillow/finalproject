geo_ggtree +
geom_nodepoint(  aes(color=node_values), size=3, alpha=1 )
tarsus_ancestral_REML =
ace(
geoData$tarsusL, ## changed wing lenght to tarsus length
geoTree,
type="continuous",
method="REML",
model="BM"
)
tarsus_ancestral_pic =
ace(
geoData$tarsusL,
geoTree,
type="continuous",
method="pic",
model="BM"
)
tarsus_ancestral_REML
tarsus_ancestral_pic
interval_width_tarsus = tarsus_ancestral_REML$CI95[,2] - tarsus_ancestral_REML$CI95[,1] ## calculate confidence interval
## using higher bound - lower bound
node_values_tarsus = c( rep(NA, nrow(geoData)), interval_width_tarsus )
## make a new data array, rep is replicate NAs (nrow(geoData) returns 13, the number of tips)
kable( data.frame( node = seq(1, length(node_values_tarsus)), width=node_values_tarsus ) )
geo_ggtree +
geom_nodepoint(aes(color=node_values_tarsus), size=3, alpha=1 )
set.seed(42) # Use the same seed value for the simulation each time it is run
sim_x = fastBM(geoTree, a=2, sig2=0.5, internal = TRUE)
D_sim = data.frame( node = seq(1, length(sim_x)), sim_x=sim_x )
kable( D_sim )
geo_ggtree +
geom_tippoint( aes(color=sim_x), size=3, alpha=1 ) +
geom_nodepoint(  aes(color=sim_x), size=3, alpha=1 )
tip_x = sim_x[1:n_tips]
reconstruction_ancestral_x =
ace(
tip_x,
geoTree,
type="continuous",
method="REML",
model="BM"
)
reconstruction_ancestral_x
D_sim$reconstruction = NA
D_sim$reconstruction[(n_tips+1):nrow(D_sim)] = reconstruction_ancestral_x$ace
D_sim[(n_tips+1):nrow(D_sim),] %>%
ggplot(aes(x=sim_x,y=reconstruction)) +
geom_point() +
geom_text( aes(label=node), color="red", vjust = 0, nudge_y = 0.005 ) +
geom_abline(slope=1, intercept=0, color="blue")
# To display the node values, ggtree expects a vector where each element
# corresponds to each node in the tree, both at the tips and at the internal
# nodes. Since we don't have values for the internal nodes, we will pad them
# with NA (Not Available) for now.
node_values = c( geoData$wingL, wing_ancestral$ace )
node_values
geo_ggtree +
geom_tippoint( aes(color=node_values), size=3, alpha=1 ) +
geom_nodepoint(  aes(color=node_values), size=3, alpha=1 )
litter_ancestral =
ace(
charstate$Average,
tree_global,
type = "continuous",
method = "REML",
model = "BM"
)
knitr::opts_chunk$set(echo = TRUE)
library(ape)
library(ggtree)
library(knitr)
library(phytools)
library(tidyverse)
library(magrittr)
tree_global = read.tree('RAxML_bipartitions.result_FIN4_raw_rooted_wBoots_4098mam1out_OK.newick')
n_tips = length(tree_global$tip.label)
root_node = tree_global$edge[(!tree_global$edge[,1] %in% tree_global$edge[,2]),1] %>% unique()
root_age = max( dist.nodes(tree_global)[,root_node] )
label_offset = 0.02 * root_age
tree_width = 5 * root_age
## drop all the non-relevant tips
charstate = read.csv('1128_subset.csv')
charstate
charstate = charstate%>%mutate(Average = as.numeric(Average))
tips <- tree_global$tip.label
tips_short = str_replace(tips, "[A-Z_]+$", "")
tree_global$tip.label = tips_short
tip_names = data.frame(Name_long=tips, Name=tips_short)
charstate %<>% left_join(tip_names)
missing_in_charstate = tree_global$tip.label[! tree_global$tip.label %in% charstate$Name]
tree_global = ape::drop.tip(tree_global, missing_in_charstate)
charstate %<>% filter(!is.na(Name_long))
rank <- match( charstate[,1], tree_global$tip.label )
charstate = charstate[match( tree_global$tip.label, charstate[,1] ), ] #the data order matches, checked manually as well.
if(! all( charstate[,1] ==tree_global$tip.label ) ){
stop("Error: tip labels and dataframe rows not in same order!")
}
litter_ancestral =
ace(
charstate$Average,
tree_global,
type = "continuous",
method = "REML",
model = "BM"
)
node_values = c(charstate$Average, round(litter_ancestral$ace, digits= 2))
node_values
globaltree = ggtree(tree_global, layout = 'circular' ) +
geom_tiplab( fontface = "italic", size= 5, offset = label_offset) +
xlim(0, 1.2) +
geom_text2(aes(label = node_values), nudge_x = 0.02, size = 4) +
geom_tippoint(aes(color=node_values), size= 4, alpha=1 ) +
geom_nodepoint( aes(color=node_values), size=3, alpha=1 ) +
scale_color_gradient(low = "red", high = "green") +
theme(legend.text=element_text(size= 40),
legend.title=element_text(size=60),
legend.key.size= unit(3,"cm"),
legend.position= "top")
globaltree
##### The following are for pic method, not sure to include or not
# litter_ancestral_pic =
#   ace(
#   charstate$Average,
#   tree_global,
#   type = "continuous",
#   method = "pic",
#   model = "BM"
# )
# node_values_pic = c(charstate$Average, round(litter_ancestral_pic$ace, digits= 2))
#
# globaltree_pic = ggtree(tree_global ) +
#   geom_tiplab( fontface = "italic", size= 10, offset = label_offset) +
#   xlim(0, 1.2) +
#   geom_text2(aes(label = node_values_pic), nudge_x = 0.02, size = 8) +
#   geom_tippoint(aes(color=node_values_pic), size= 8, alpha=1 ) +
#   scale_color_gradient(low = "red", high = "green") +
#   theme(legend.text=element_text(size= 40),
#         legend.title=element_text(size=60),
#         legend.key.size= unit(3,"cm"),
#         legend.position= "top")
#
# globaltree_pic
knitr::opts_chunk$set(echo = TRUE)
library(ape)
library(phylobase)
library(phytools)
library(tidyverse)
library(knitr)
library(ggtree)
library(tidyverse)
library(magrittr)
data(geospiza_raw)
geoTree = geospiza_raw$tree
geoData = geospiza_raw$data
# Remove one tip in tree without morphological data
geoTree = drop.tip(geoTree, "olivacea")
# The methods we use below assume that the rows of the character data are in the
# same order as the tip labels. The following line takes are of this. These data
# are in the correct order to begin with, but it is always good to include a line
# like this to rearrange if needed.
geoData = geoData[ match( row.names(geoData), geoTree$tip.label  ), ]
# Double check that labels are the same, in case some were missing or duplicated
if(! all( row.names(geoData)==geoTree$tip.label ) ){
stop("Error: tip labels and dataframe rows not in same order!")
}
# Count the number of tips
n_tips = length(geoTree$tip.label)
# Get the root node by finding the node that is a parent (in column 1 of edge)
# but not a child (in column 2 of edge)
root_node = geoTree$edge[(!geoTree$edge[,1] %in% geoTree$edge[,2]),1] %>% unique()
# Get the maximum distance from the root to another node, which will be for a tip.
# Since this tree happens to be ultrametric, this will be the root age
root_age = max( dist.nodes(geoTree)[,root_node] )
# This isn't necessary, but since we don't know the units of edge length let's rescale
# the tree so that the age of the root is 1.
geoTree$edge.length = geoTree$edge.length / root_age
# And now recalculate the root age to make sure things look good
root_age = max( dist.nodes(geoTree)[,root_node] )
# kable prints pretty tables
kable(geoData)
# First, get some values that will help us scale the tree on the page well. Would
# by nice if ggtree did that, but it doesn't.
label_offset = 0.05 * root_age
tree_width = 1.5 * root_age
geo_ggtree = ggtree( geoTree ) +
geom_tiplab( fontface = "italic", offset=label_offset ) +
xlim(0, tree_width) +
geom_text2(aes(label=node), col="red", nudge_x=label_offset/2 )
geo_ggtree
# To display the node values, ggtree expects a vector where each element
# corresponds to each node in the tree, both at the tips and at the internal
# nodes. Since we don't have values for the internal nodes, we will pad them
# with NA (Not Available) for now.
node_values = c( geoData$wingL, rep(NA, n_tips-1) )
geo_ggtree +
geom_tippoint( aes(color=node_values), size=3, alpha=1 )
wing_ancestral =
ace(
geoData$wingL,
geoTree,
type="continuous",
method="REML",
model="BM"
)
wing_ancestral
# To display the node values, ggtree expects a vector where each element
# corresponds to each node in the tree, both at the tips and at the internal
# nodes. Since we don't have values for the internal nodes, we will pad them
# with NA (Not Available) for now.
node_values = c( geoData$wingL, wing_ancestral$ace )
node_values
geo_ggtree +
geom_tippoint( aes(color=node_values), size=3, alpha=1 ) +
geom_nodepoint(  aes(color=node_values), size=3, alpha=1 )
wing_ancestral_pic =
ace(
geoData$wingL,
geoTree,
type="continuous",
method="pic",
model="BM"
)
wing_ancestral_pic
D_methods = data.frame(
reml = wing_ancestral$ace,
pic = wing_ancestral_pic$ace
)
# Add node numbers to the data frame
D_methods$node = seq(1:nrow(D_methods)) + n_tips
D_methods %>%
ggplot(aes(x=reml,y=pic)) +
geom_point() +
geom_text( aes(label=node), color="red", vjust = 0, nudge_y = 0.005 ) +
geom_abline(slope=1, intercept=0, color="blue")
interval_width = wing_ancestral$CI95[,2] - wing_ancestral$CI95[,1]
node_values = c( rep(NA, nrow(geoData)), interval_width )
kable( data.frame( node = seq(1, length(node_values)), width=node_values ) )
geo_ggtree +
geom_nodepoint(  aes(color=node_values), size=3, alpha=1 )
tarsus_ancestral_REML =
ace(
geoData$tarsusL, ## changed wing lenght to tarsus length
geoTree,
type="continuous",
method="REML",
model="BM"
)
tarsus_ancestral_pic =
ace(
geoData$tarsusL,
geoTree,
type="continuous",
method="pic",
model="BM"
)
tarsus_ancestral_REML
tarsus_ancestral_pic
interval_width_tarsus = tarsus_ancestral_REML$CI95[,2] - tarsus_ancestral_REML$CI95[,1] ## calculate confidence interval
## using higher bound - lower bound
node_values_tarsus = c( rep(NA, nrow(geoData)), interval_width_tarsus )
## make a new data array, rep is replicate NAs (nrow(geoData) returns 13, the number of tips)
kable( data.frame( node = seq(1, length(node_values_tarsus)), width=node_values_tarsus ) )
geo_ggtree +
geom_nodepoint(aes(color=node_values_tarsus), size=3, alpha=1 )
set.seed(42) # Use the same seed value for the simulation each time it is run
sim_x = fastBM(geoTree, a=2, sig2=0.5, internal = TRUE)
D_sim = data.frame( node = seq(1, length(sim_x)), sim_x=sim_x )
kable( D_sim )
geo_ggtree +
geom_tippoint( aes(color=sim_x), size=3, alpha=1 ) +
geom_nodepoint(  aes(color=sim_x), size=3, alpha=1 )
tip_x = sim_x[1:n_tips]
reconstruction_ancestral_x =
ace(
tip_x,
geoTree,
type="continuous",
method="REML",
model="BM"
)
reconstruction_ancestral_x
D_sim$reconstruction = NA
D_sim$reconstruction[(n_tips+1):nrow(D_sim)] = reconstruction_ancestral_x$ace
D_sim[(n_tips+1):nrow(D_sim),] %>%
ggplot(aes(x=sim_x,y=reconstruction)) +
geom_point() +
geom_text( aes(label=node), color="red", vjust = 0, nudge_y = 0.005 ) +
geom_abline(slope=1, intercept=0, color="blue")
View(geoData)
knitr::opts_chunk$set(echo = TRUE)
library(ape)
library(ggtree)
library(knitr)
library(phytools)
library(tidyverse)
library(magrittr)
tree_global = read.tree('RAxML_bipartitions.result_FIN4_raw_rooted_wBoots_4098mam1out_OK.newick')
n_tips = length(tree_global$tip.label)
root_node = tree_global$edge[(!tree_global$edge[,1] %in% tree_global$edge[,2]),1] %>% unique()
root_age = max( dist.nodes(tree_global)[,root_node] )
label_offset = 0.02 * root_age
tree_width = 5 * root_age
## drop all the non-relevant tips
charstate = read.csv('1128_subset.csv')
charstate
charstate = charstate%>%mutate(Average = as.numeric(Average))
tips <- tree_global$tip.label
tips_short = str_replace(tips, "[A-Z_]+$", "")
tree_global$tip.label = tips_short
tip_names = data.frame(Name_long=tips, Name=tips_short)
charstate %<>% left_join(tip_names)
missing_in_charstate = tree_global$tip.label[! tree_global$tip.label %in% charstate$Name]
tree_global = ape::drop.tip(tree_global, missing_in_charstate)
charstate %<>% filter(!is.na(Name_long))
rank <- match( charstate[,1], tree_global$tip.label )
charstate = charstate[match( tree_global$tip.label, charstate[,1] ), ] #the data order matches, checked manually as well.
if(! all( charstate[,1] ==tree_global$tip.label ) ){
stop("Error: tip labels and dataframe rows not in same order!")
}
litter_ancestral =
ace(
charstate$Average,
tree_global,
type = "continuous",
method = "REML",
model = "BM"
)
node_values = c(charstate$Average, round(litter_ancestral$ace, digits= 2))
node_values
globaltree = ggtree(tree_global, layout = 'circular' ) +
geom_tiplab( fontface = "italic", size= 5, offset = label_offset) +
xlim(0, 1.2) +
geom_text2(aes(label = node_values), nudge_x = 0.02, size = 4) +
geom_tippoint(aes(color=node_values), size= 4, alpha=1 ) +
geom_nodepoint( aes(color=node_values), size=3, alpha=1 ) +
scale_color_gradient(low = "red", high = "green") +
theme(legend.text=element_text(size= 40),
legend.title=element_text(size=60),
legend.key.size= unit(3,"cm"),
legend.position= "top")
globaltree
##### The following are for pic method, not sure to include or not
# litter_ancestral_pic =
#   ace(
#   charstate$Average,
#   tree_global,
#   type = "continuous",
#   method = "pic",
#   model = "BM"
# )
# node_values_pic = c(charstate$Average, round(litter_ancestral_pic$ace, digits= 2))
#
# globaltree_pic = ggtree(tree_global ) +
#   geom_tiplab( fontface = "italic", size= 10, offset = label_offset) +
#   xlim(0, 1.2) +
#   geom_text2(aes(label = node_values_pic), nudge_x = 0.02, size = 8) +
#   geom_tippoint(aes(color=node_values_pic), size= 8, alpha=1 ) +
#   scale_color_gradient(low = "red", high = "green") +
#   theme(legend.text=element_text(size= 40),
#         legend.title=element_text(size=60),
#         legend.key.size= unit(3,"cm"),
#         legend.position= "top")
#
# globaltree_pic
knitr::opts_chunk$set(echo = TRUE)
library(ape)
library(phylobase)
library(phytools)
library(tidyverse)
library(knitr)
library(ggtree)
library(tidyverse)
library(magrittr)
# To display the node values, ggtree expects a vector where each element
# corresponds to each node in the tree, both at the tips and at the internal
# nodes. Since we don't have values for the internal nodes, we will pad them
# with NA (Not Available) for now.
node_values = c( geoData$wingL, wing_ancestral$ace )
knitr::opts_chunk$set(echo = TRUE)
library(ape)
library(phylobase)
library(phytools)
library(tidyverse)
library(knitr)
library(ggtree)
library(tidyverse)
library(magrittr)
data(geospiza_raw)
geoTree = geospiza_raw$tree
geoData = geospiza_raw$data
# Remove one tip in tree without morphological data
geoTree = drop.tip(geoTree, "olivacea")
# The methods we use below assume that the rows of the character data are in the
# same order as the tip labels. The following line takes are of this. These data
# are in the correct order to begin with, but it is always good to include a line
# like this to rearrange if needed.
geoData = geoData[ match( row.names(geoData), geoTree$tip.label  ), ]
# Double check that labels are the same, in case some were missing or duplicated
if(! all( row.names(geoData)==geoTree$tip.label ) ){
stop("Error: tip labels and dataframe rows not in same order!")
}
# Count the number of tips
n_tips = length(geoTree$tip.label)
# Get the root node by finding the node that is a parent (in column 1 of edge)
# but not a child (in column 2 of edge)
root_node = geoTree$edge[(!geoTree$edge[,1] %in% geoTree$edge[,2]),1] %>% unique()
# Get the maximum distance from the root to another node, which will be for a tip.
# Since this tree happens to be ultrametric, this will be the root age
root_age = max( dist.nodes(geoTree)[,root_node] )
# This isn't necessary, but since we don't know the units of edge length let's rescale
# the tree so that the age of the root is 1.
geoTree$edge.length = geoTree$edge.length / root_age
# And now recalculate the root age to make sure things look good
root_age = max( dist.nodes(geoTree)[,root_node] )
# kable prints pretty tables
kable(geoData)
# First, get some values that will help us scale the tree on the page well. Would
# by nice if ggtree did that, but it doesn't.
label_offset = 0.05 * root_age
tree_width = 1.5 * root_age
geo_ggtree = ggtree( geoTree ) +
geom_tiplab( fontface = "italic", offset=label_offset ) +
xlim(0, tree_width) +
geom_text2(aes(label=node), col="red", nudge_x=label_offset/2 )
geo_ggtree
# To display the node values, ggtree expects a vector where each element
# corresponds to each node in the tree, both at the tips and at the internal
# nodes. Since we don't have values for the internal nodes, we will pad them
# with NA (Not Available) for now.
node_values = c( geoData$wingL, rep(NA, n_tips-1) )
geo_ggtree +
geom_tippoint( aes(color=node_values), size=3, alpha=1 )
wing_ancestral =
ace(
geoData$wingL,
geoTree,
type="continuous",
method="REML",
model="BM"
)
wing_ancestral
# To display the node values, ggtree expects a vector where each element
# corresponds to each node in the tree, both at the tips and at the internal
# nodes. Since we don't have values for the internal nodes, we will pad them
# with NA (Not Available) for now.
node_values = c( geoData$wingL, wing_ancestral$ace )
node_values
geo_ggtree +
geom_tippoint( aes(color=node_values), size=3, alpha=1 ) +
geom_text2(aes(label = node_values_pic), nudge_x = 0.02, size = 8) +
geom_nodepoint(  aes(color=node_values), size=3, alpha=1 )
# To display the node values, ggtree expects a vector where each element
# corresponds to each node in the tree, both at the tips and at the internal
# nodes. Since we don't have values for the internal nodes, we will pad them
# with NA (Not Available) for now.
node_values = c( geoData$wingL, wing_ancestral$ace )
node_values
geo_ggtree +
geom_tippoint( aes(color=node_values), size=3, alpha=1 ) +
geom_text2(aes(label = node_values), nudge_x = 0.02, size = 8) +
geom_nodepoint(  aes(color=node_values), size=3, alpha=1 )
# To display the node values, ggtree expects a vector where each element
# corresponds to each node in the tree, both at the tips and at the internal
# nodes. Since we don't have values for the internal nodes, we will pad them
# with NA (Not Available) for now.
node_values = c( geoData$wingL, wing_ancestral$ace )
node_values
geo_ggtree +
geom_tippoint( aes(color=node_values), size=3, alpha=1 ) +
geom_text2(aes(label = node_values), nudge_x = 0.02, size = 1) +
geom_nodepoint(  aes(color=node_values), size=3, alpha=1 )
# To display the node values, ggtree expects a vector where each element
# corresponds to each node in the tree, both at the tips and at the internal
# nodes. Since we don't have values for the internal nodes, we will pad them
# with NA (Not Available) for now.
node_values = c( geoData$wingL, wing_ancestral$ace )
node_values
geo_ggtree +
geom_tippoint( aes(color=node_values), size=3, alpha=1 ) +
geom_text2(aes(label = node_values), nudge_x = 0.02, size = 3) +
geom_nodepoint(  aes(color=node_values), size=3, alpha=1 )
# To display the node values, ggtree expects a vector where each element
# corresponds to each node in the tree, both at the tips and at the internal
# nodes. Since we don't have values for the internal nodes, we will pad them
# with NA (Not Available) for now.
node_values = c( geoData$wingL, round(wing_ancestral$ace, digits = 2) )
node_values
geo_ggtree +
geom_tippoint( aes(color=node_values), size=3, alpha=1 ) +
geom_text2(aes(label = node_values), nudge_x = 0.02, size = 3) +
geom_nodepoint(  aes(color=node_values), size=3, alpha=1 )
# To display the node values, ggtree expects a vector where each element
# corresponds to each node in the tree, both at the tips and at the internal
# nodes. Since we don't have values for the internal nodes, we will pad them
# with NA (Not Available) for now.
node_values = c( geoData$wingL, round(wing_ancestral$ace, digits = 2) )
node_values
geo_ggtree +
geom_tippoint( aes(color=node_values), size=3, alpha=1 ) +
geom_text2(aes(label = node_values), nudge_y = 0.2, size = 3) +
geom_nodepoint(  aes(color=node_values), size=3, alpha=1 )
# To display the node values, ggtree expects a vector where each element
# corresponds to each node in the tree, both at the tips and at the internal
# nodes. Since we don't have values for the internal nodes, we will pad them
# with NA (Not Available) for now.
node_values = c( round(geoData$wingL, digits = 2), round(wing_ancestral$ace, digits = 2) )
node_values
geo_ggtree +
geom_tippoint( aes(color=node_values), size=3, alpha=1 ) +
geom_text2(aes(label = node_values), nudge_y = 0.2, size = 3) +
geom_nodepoint(  aes(color=node_values), size=3, alpha=1 )
